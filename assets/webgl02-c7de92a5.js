import{l as De,C as B,m as H,U as z,n as E,D as Ce,o as Ae,p as ze,q as Ie,r as R,V as S,s as He,R as Te,E as te,N as Ee,t as I,u as p,v as F,L as ue,P as re,w as ne,S as se,M as K,x as X,y as k,z as V,F as Ne,G as Fe,H as ce,I as Me,J as ye,K as Oe,Q as Le,T as Ge,X as ke,Y as Ve,Z as We,_ as W,$ as we,a0 as be,a1 as ae,a2 as de,W as Ke,a as Xe,c as Ze,b as Ye,a3 as _,a4 as fe,a5 as pe,i as Q,a6 as qe,k as $e,A as Qe,O as je}from"./solid-e14309dc.js";import{G as Je}from"./lil-gui.esm-b4f18ba3.js";/**
 * postprocessing v6.31.0 build Sun May 07 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van RÃ¼schen
 * @license Zlib
 */var oe="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Re="",g="srgb",Y="srgb-linear",et=Number(ne.replace(/\D+/g,"")),_e=et>=152,tt=new Map([[Me,Y],[ye,g]]),st=new Map([[Y,Me],[g,ye]]);function N(e){return e===null?null:_e?e.outputColorSpace:tt.get(e.outputEncoding)}function U(e,t){e!==null&&(_e?e.colorSpace=t:e.encoding=st.get(t))}var d={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},O={DEFAULT:0,KEEP_MAX_DEPTH:1,DISCARD_MAX_DEPTH:2},C={NONE:0,DEPTH:1,CONVOLUTION:2},f={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},le={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},it=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`,rt="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",nt=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],at=class extends I{constructor(e=new de){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new p(null),texelSize:new p(new de),scale:new p(1),kernel:new p(0)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:it,vertexShader:rt}),this.setTexelSize(e.x,e.y),this.kernelSize=le.MEDIUM}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get kernelSequence(){return nt[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t,e*.5,t*.5)}setSize(e,t){const s=1/e,i=1/t;this.uniforms.texelSize.value.set(s,i,s*.5,i*.5)}},ot=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`,Be=class extends I{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new p(null),opacity:new p(1)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ot,vertexShader:oe})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},lt=`#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`,ht=class extends I{constructor(){super({name:"DepthMaskMaterial",defines:{DEPTH_EPSILON:"0.0001",DEPTH_PACKING_0:"0",DEPTH_PACKING_1:"0",DEPTH_TEST_STRATEGY:O.KEEP_MAX_DEPTH},uniforms:{inputBuffer:new p(null),depthBuffer0:new p(null),depthBuffer1:new p(null),cameraNearFar:new p(new E(1,1))},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:lt,vertexShader:oe}),this.depthMode=ue}set depthBuffer0(e){this.uniforms.depthBuffer0.value=e}set depthPacking0(e){this.defines.DEPTH_PACKING_0=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer0(e,t=H){this.depthBuffer0=e,this.depthPacking0=t}set depthBuffer1(e){this.uniforms.depthBuffer1.value=e}set depthPacking1(e){this.defines.DEPTH_PACKING_1=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer1(e,t=H){this.depthBuffer1=e,this.depthPacking1=t}get maxDepthStrategy(){return Number(this.defines.DEPTH_TEST_STRATEGY)}set maxDepthStrategy(e){this.defines.DEPTH_TEST_STRATEGY=e.toFixed(0),this.needsUpdate=!0}get keepFar(){return this.maxDepthStrategy}set keepFar(e){this.maxDepthStrategy=e?O.KEEP_MAX_DEPTH:O.DISCARD_MAX_DEPTH}getMaxDepthStrategy(){return this.maxDepthStrategy}setMaxDepthStrategy(e){this.maxDepthStrategy=e}get epsilon(){return Number(this.defines.DEPTH_EPSILON)}set epsilon(e){this.defines.DEPTH_EPSILON=e.toFixed(16),this.needsUpdate=!0}getEpsilon(){return this.epsilon}setEpsilon(e){this.epsilon=e}get depthMode(){return Number(this.defines.DEPTH_MODE)}set depthMode(e){let t;switch(e){case Ve:t="false";break;case ke:t="true";break;case te:t="abs(d1 - d0) <= DEPTH_EPSILON";break;case Ee:t="abs(d1 - d0) > DEPTH_EPSILON";break;case ue:t="d0 > d1";break;case Ge:t="d0 >= d1";break;case Le:t="d0 <= d1";break;case Oe:default:t="d0 < d1";break}this.defines.DEPTH_MODE=e.toFixed(0),this.defines["depthTest(d0, d1)"]=t,this.needsUpdate=!0}getDepthMode(){return this.depthMode}setDepthMode(e){this.depthMode=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNearFar.value.set(e.near,e.far),e instanceof re?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},ut=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`,ct="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",dt=class extends I{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new p(null),texelSize:new p(new E)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:ut,vertexShader:ct})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},ft=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,pt="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",vt=class extends I{constructor(e,t,s,i,r=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:ne.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new p(null),depthBuffer:new p(null),resolution:new p(new E),texelSize:new p(new E),cameraNear:new p(.3),cameraFar:new p(1e3),aspect:new p(1),time:new p(0)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:r}),e&&this.setShaderParts(e),t&&this.setDefines(t),s&&this.setUniforms(s),this.copyCameraSettings(i)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=H){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=ft.replace(f.FRAGMENT_HEAD,e.get(f.FRAGMENT_HEAD)||"").replace(f.FRAGMENT_MAIN_UV,e.get(f.FRAGMENT_MAIN_UV)||"").replace(f.FRAGMENT_MAIN_IMAGE,e.get(f.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=pt.replace(f.VERTEX_HEAD,e.get(f.VERTEX_HEAD)||"").replace(f.VERTEX_MAIN_SUPPORT,e.get(f.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof re?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const s=this.uniforms;s.resolution.value.set(e,t),s.texelSize.value.set(1/e,1/t),s.aspect.value=e/t}static get Section(){return f}},mt=`#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,gt=class extends I{constructor(e=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:ne.replace(/\D+/g,"")},uniforms:{inputBuffer:new p(null),threshold:new p(0),smoothing:new p(1),range:new p(null)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:mt,vertexShader:oe}),this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},St=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`,xt="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",Tt=class extends I{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new p(null),supportBuffer:new p(null),texelSize:new p(new E),radius:new p(.85)},blending:F,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:St,vertexShader:xt})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}set supportBuffer(e){this.uniforms.supportBuffer.value=e}get radius(){return this.uniforms.radius.value}set radius(e){this.uniforms.radius.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Et=new De,P=null;function Mt(){if(P===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);P=new We,P.setAttribute!==void 0?(P.setAttribute("position",new W(e,3)),P.setAttribute("uv",new W(t,2))):(P.addAttribute("position",new W(e,3)),P.addAttribute("uv",new W(t,2)))}return P}var w=class{constructor(e="Pass",t=new se,s=Et){this.name=e,this.renderer=null,this.scene=t,this.camera=s,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new K(Mt(),e),t.frustumCulled=!1,this.scene===null&&(this.scene=new se),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=H){}render(e,t,s,i,r){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,s){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof R||t instanceof we||t instanceof be||t instanceof w)&&this[e].dispose()}}},yt=class extends w{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new Be,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new R(1,1,{minFilter:X,magFilter:X,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,s,i,r){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,s){s!==void 0&&(this.renderTarget.texture.type=s,s!==z?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":N(e)===g&&U(this.renderTarget.texture,g))}},wt=class extends w{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,s,i,r){const n=e.state.buffers.stencil;n.setLocked(!1),n.setTest(!1)}},ve=new B,he=class extends w{constructor(e=!0,t=!0,s=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=s,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,s){this.color=e,this.depth=t,this.stencil=s}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,s,i,r){const n=this.overrideClearColor,a=this.overrideClearAlpha,o=e.getClearAlpha(),l=n!==null,c=a>=0;l?(e.getClearColor(ve),e.setClearColor(n,c?a:o)):c&&e.setClearAlpha(a),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),l?e.setClearColor(ve,o):c&&e.setClearAlpha(o)}},D=-1,y=class extends ae{constructor(e,t=D,s=D,i=1){super(),this.resizable=e,this.baseSize=new E(1,1),this.preferredSize=new E(t,s),this.target=this.preferredSize,this.s=i,this.effectiveSize=new E,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,s=this.effectiveSize,i=this.scale;t.width!==D?s.width=t.width:t.height!==D?s.width=Math.round(t.height*(e.width/Math.max(e.height,1))):s.width=Math.round(e.width*i),t.height!==D?s.height=t.height:t.width!==D?s.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):s.height=Math.round(e.height*i)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(D),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return D}},j=!1,me=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let s;if(t.material.flatShading)switch(t.material.side){case V:s=this.materialsFlatShadedDoubleSide;break;case k:s=this.materialsFlatShadedBackSide;break;default:s=this.materialsFlatShaded;break}else switch(t.material.side){case V:s=this.materialsDoubleSide;break;case k:s=this.materialsBackSide;break;default:s=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=s[2]:t.isInstancedMesh?t.material=s[1]:t.material=s[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof I))return e.clone();const t=e.uniforms,s=new Map;for(const r in t){const n=t[r].value;n.isRenderTargetTexture&&(t[r].value=null,s.set(r,n))}const i=e.clone();for(const r of s)t[r[0]].value=r[1],i.uniforms[r[0]].value=r[1];return i}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const s of t)s.uniforms=Object.assign({},e.uniforms),s.side=Ne;t[2].skinning=!0,this.materialsBackSide=t.map(s=>{const i=this.cloneMaterial(s);return i.uniforms=Object.assign({},e.uniforms),i.side=k,i}),this.materialsDoubleSide=t.map(s=>{const i=this.cloneMaterial(s);return i.uniforms=Object.assign({},e.uniforms),i.side=V,i}),this.materialsFlatShaded=t.map(s=>{const i=this.cloneMaterial(s);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i}),this.materialsFlatShadedBackSide=t.map(s=>{const i=this.cloneMaterial(s);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=k,i}),this.materialsFlatShadedDoubleSide=t.map(s=>{const i=this.cloneMaterial(s);return i.uniforms=Object.assign({},e.uniforms),i.flatShading=!0,i.side=V,i})}}render(e,t,s){const i=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,j){const r=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,s);for(const n of r)n[0].material=n[1];this.meshCount!==r.size&&r.clear()}else{const r=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,s),t.overrideMaterial=r}e.shadowMap.enabled=i}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return j}static set workaroundEnabled(e){j=e}},Ue=class extends w{constructor(e,t,s=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new he,this.overrideMaterialManager=s===null?null:new me(s),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new me(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,s,i,r){const n=this.scene,a=this.camera,o=this.selection,l=a.layers.mask,c=n.background,m=e.shadowMap.autoUpdate,v=this.renderToScreen?null:t;o!==null&&a.layers.set(o.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(n.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(v),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,n,a):e.render(n,a),a.layers.mask=l,n.background=c,e.shadowMap.autoUpdate=m}},bt=class extends w{constructor(e,t,{renderTarget:s,resolutionScale:i=1,width:r=y.AUTO_SIZE,height:n=y.AUTO_SIZE,resolutionX:a=r,resolutionY:o=n}={}){super("DepthPass"),this.needsSwap=!1,this.renderPass=new Ue(e,t,new Fe({depthPacking:Te}));const l=this.renderPass;l.skipShadowMapUpdate=!0,l.ignoreBackground=!0;const c=l.getClearPass();c.overrideClearColor=new B(16777215),c.overrideClearAlpha=1,this.renderTarget=s,this.renderTarget===void 0&&(this.renderTarget=new R(1,1,{minFilter:ce,magFilter:ce}),this.renderTarget.texture.name="DepthPass.Target");const m=this.resolution=new y(this,a,o,i);m.addEventListener("change",v=>this.setSize(m.baseWidth,m.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,s,i,r){const n=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,n)}setSize(e,t){const s=this.resolution;s.setBaseSize(e,t),this.renderTarget.setSize(s.width,s.height)}};function ge(e,t,s){for(const i of t){const r="$1"+e+i.charAt(0).toUpperCase()+i.slice(1),n=new RegExp("([^\\.])(\\b"+i+"\\b)","g");for(const a of s.entries())a[1]!==null&&s.set(a[0],a[1].replace(n,r))}}function Rt(e,t,s){let i=t.getFragmentShader(),r=t.getVertexShader();const n=i!==void 0&&/mainImage/.test(i),a=i!==void 0&&/mainUv/.test(i);if(s.attributes|=t.getAttributes(),i===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(a&&s.attributes&C.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!n&&!a)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const o=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,l=s.shaderParts;let c=l.get(f.FRAGMENT_HEAD)||"",m=l.get(f.FRAGMENT_MAIN_UV)||"",v=l.get(f.FRAGMENT_MAIN_IMAGE)||"",h=l.get(f.VERTEX_HEAD)||"",u=l.get(f.VERTEX_MAIN_SUPPORT)||"";const b=new Set,x=new Set;if(a&&(m+=`	${e}MainUv(UV);
`,s.uvTransformation=!0),r!==null&&/mainSupport/.test(r)){const T=/mainSupport *\([\w\s]*?uv\s*?\)/.test(r);u+=`	${e}MainSupport(`,u+=T?`vUv);
`:`);
`;for(const M of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const $ of M[1].split(/\s*,\s*/))s.varyings.add($),b.add($),x.add($);for(const M of r.matchAll(o))x.add(M[1])}for(const T of i.matchAll(o))x.add(T[1]);for(const T of t.defines.keys())x.add(T.replace(/\([\w\s,]*\)/g,""));for(const T of t.uniforms.keys())x.add(T);x.delete("while"),x.delete("for"),x.delete("if"),t.uniforms.forEach((T,M)=>s.uniforms.set(e+M.charAt(0).toUpperCase()+M.slice(1),T)),t.defines.forEach((T,M)=>s.defines.set(e+M.charAt(0).toUpperCase()+M.slice(1),T));const q=new Map([["fragment",i],["vertex",r]]);ge(e,x,s.defines),ge(e,x,q),i=q.get("fragment"),r=q.get("vertex");const G=t.blendMode;if(s.blendModes.set(G.blendFunction,G),n){t.inputColorSpace!==null&&t.inputColorSpace!==s.colorSpace&&(v+=t.inputColorSpace===g?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==Re?s.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(s.colorSpace=t.inputColorSpace);const T=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;v+=`${e}MainImage(color0, UV, `,s.attributes&C.DEPTH&&T.test(i)&&(v+="depth, ",s.readDepth=!0),v+=`color1);
	`;const M=e+"BlendOpacity";s.uniforms.set(M,G.opacity),v+=`color0 = blend${G.blendFunction}(color0, color1, ${M});

	`,c+=`uniform float ${M};

`}if(c+=i+`
`,r!==null&&(h+=r+`
`),l.set(f.FRAGMENT_HEAD,c),l.set(f.FRAGMENT_MAIN_UV,m),l.set(f.FRAGMENT_MAIN_IMAGE,v),l.set(f.VERTEX_HEAD,h),l.set(f.VERTEX_MAIN_SUPPORT,u),t.extensions!==null)for(const T of t.extensions)s.extensions.add(T)}}var _t=class extends w{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new vt(null,null,null,e),this.listener=s=>this.handleEvent(s),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,s)=>s.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new Ht;let t=0;for(const a of this.effects)if(a.blendMode.blendFunction===d.DST)e.attributes|=a.getAttributes()&C.DEPTH;else{if(e.attributes&a.getAttributes()&C.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${a.name})`);Rt("e"+t++,a,e)}let s=e.shaderParts.get(f.FRAGMENT_HEAD),i=e.shaderParts.get(f.FRAGMENT_MAIN_IMAGE),r=e.shaderParts.get(f.FRAGMENT_MAIN_UV);const n=/\bblend\b/g;for(const a of e.blendModes.values())s+=a.getShaderCode().replace(n,`blend${a.blendFunction}`)+`
`;e.attributes&C.DEPTH?(e.readDepth&&(i=`float depth = readDepth(UV);

	`+i),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===g&&(i+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(r=`vec2 transformedUv = vUv;
`+r,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(f.FRAGMENT_HEAD,s),e.shaderParts.set(f.FRAGMENT_MAIN_IMAGE,i),e.shaderParts.set(f.FRAGMENT_MAIN_UV,r);for(const[a,o]of e.shaderParts)o!==null&&e.shaderParts.set(a,o.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=H){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const s of this.effects)s.setDepthTexture(e,t)}render(e,t,s,i,r){for(const n of this.effects)n.update(e,t,i);if(!this.skipRendering||this.renderToScreen){const n=this.fullscreenMaterial;n.inputBuffer=t.texture,n.time+=i*this.timeScale,e.setRenderTarget(this.renderToScreen?null:s),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const s of this.effects)s.setSize(e,t)}initialize(e,t,s){this.renderer=e;for(const i of this.effects)i.initialize(e,t,s);this.updateMaterial(),s!==void 0&&s!==z&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},Bt=class extends w{constructor({kernelSize:e=le.MEDIUM,resolutionScale:t=.5,width:s=y.AUTO_SIZE,height:i=y.AUTO_SIZE,resolutionX:r=s,resolutionY:n=i}={}){super("KawaseBlurPass"),this.renderTargetA=new R(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const a=this.resolution=new y(this,r,n,t);a.addEventListener("change",o=>this.setSize(a.baseWidth,a.baseHeight)),this._blurMaterial=new at,this._blurMaterial.kernelSize=e,this.copyMaterial=new Be}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(e){this._blurMaterial=e}get dithering(){return this.copyMaterial.dithering}set dithering(e){this.copyMaterial.dithering=e}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(e){this.blurMaterial.kernelSize=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,s,i,r){const n=this.scene,a=this.camera,o=this.renderTargetA,l=this.renderTargetB,c=this.blurMaterial,m=c.kernelSequence;let v=t;this.fullscreenMaterial=c;for(let h=0,u=m.length;h<u;++h){const b=h&1?l:o;c.kernel=m[h],c.inputBuffer=v.texture,e.setRenderTarget(b),e.render(n,a),v=b}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=v.texture,e.setRenderTarget(this.renderToScreen?null:s),e.render(n,a)}setSize(e,t){const s=this.resolution;s.setBaseSize(e,t);const i=s.width,r=s.height;this.renderTargetA.setSize(i,r),this.renderTargetB.setSize(i,r),this.blurMaterial.setSize(e,t)}initialize(e,t,s){s!==void 0&&(this.renderTargetA.texture.type=s,this.renderTargetB.texture.type=s,s!==z?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):N(e)===g&&(U(this.renderTargetA.texture,g),U(this.renderTargetB.texture,g)))}static get AUTO_SIZE(){return y.AUTO_SIZE}},Ut=class extends w{constructor({renderTarget:e,luminanceRange:t,colorOutput:s,resolutionScale:i=1,width:r=y.AUTO_SIZE,height:n=y.AUTO_SIZE,resolutionX:a=r,resolutionY:o=n}={}){super("LuminancePass"),this.fullscreenMaterial=new gt(s,t),this.needsSwap=!1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new R(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const l=this.resolution=new y(this,a,o,i);l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,s,i,r){const n=this.fullscreenMaterial;n.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const s=this.resolution;s.setBaseSize(e,t),this.renderTarget.setSize(s.width,s.height)}initialize(e,t,s){s!==void 0&&s!==z&&(this.renderTarget.texture.type=s,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Pt=class extends w{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new he(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,s,i,r){const n=e.getContext(),a=e.state.buffers,o=this.scene,l=this.camera,c=this.clearPass,m=this.inverted?0:1,v=1-m;a.color.setMask(!1),a.depth.setMask(!1),a.color.setLocked(!0),a.depth.setLocked(!0),a.stencil.setTest(!0),a.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),a.stencil.setFunc(n.ALWAYS,m,4294967295),a.stencil.setClear(v),a.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?c.render(e,null):(c.render(e,t),c.render(e,s))),this.renderToScreen?(e.setRenderTarget(null),e.render(o,l)):(e.setRenderTarget(t),e.render(o,l),e.setRenderTarget(s),e.render(o,l)),a.color.setLocked(!1),a.depth.setLocked(!1),a.stencil.setLocked(!1),a.stencil.setFunc(n.EQUAL,1,4294967295),a.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),a.stencil.setLocked(!0)}},Dt=class extends w{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new R(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new dt,this.upsamplingMaterial=new Tt,this.resolution=new E}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(e){if(this.levels!==e){const t=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let s=0;s<e;++s){const i=t.clone();i.texture.name="Downsampling.Mipmap"+s,this.downsamplingMipmaps.push(i)}this.upsamplingMipmaps.push(t);for(let s=1,i=e-1;s<i;++s){const r=t.clone();r.texture.name="Upsampling.Mipmap"+s,this.upsamplingMipmaps.push(r)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(e){this.upsamplingMaterial.radius=e}render(e,t,s,i,r){const{scene:n,camera:a}=this,{downsamplingMaterial:o,upsamplingMaterial:l}=this,{downsamplingMipmaps:c,upsamplingMipmaps:m}=this;let v=t;this.fullscreenMaterial=o;for(let h=0,u=c.length;h<u;++h){const b=c[h];o.setSize(v.width,v.height),o.inputBuffer=v.texture,e.setRenderTarget(b),e.render(n,a),v=b}this.fullscreenMaterial=l;for(let h=m.length-1;h>=0;--h){const u=m[h];l.setSize(v.width,v.height),l.inputBuffer=v.texture,l.supportBuffer=c[h].texture,e.setRenderTarget(u),e.render(n,a),v=u}}setSize(e,t){const s=this.resolution;s.set(e,t);let i=s.width,r=s.height;for(let n=0,a=this.downsamplingMipmaps.length;n<a;++n)i=Math.round(i*.5),r=Math.round(r*.5),this.downsamplingMipmaps[n].setSize(i,r),n<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[n].setSize(i,r)}initialize(e,t,s){if(s!==void 0){const i=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const r of i)r.texture.type=s;if(s!==z)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(N(e)===g)for(const r of i)U(r.texture,g)}}dispose(){super.dispose();for(const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))e.dispose()}},Ct=class extends w{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.input=t}setInput(e){this.input=e}render(e,t,s,i,r){const n=this.fullscreenMaterial.uniforms;t!==null&&n!==void 0&&n[this.input]!==void 0&&(n[this.input].value=t.texture),e.setRenderTarget(this.renderToScreen?null:s),e.render(this.scene,this.camera)}initialize(e,t,s){s!==void 0&&s!==z&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},J=1/1e3,At=1e3,zt=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*J}get fixedDelta(){return this._fixedDelta*J}set fixedDelta(e){this._fixedDelta=e*At}get elapsed(){return this._elapsed*J}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},It=class{constructor(e=null,{depthBuffer:t=!0,stencilBuffer:s=!1,multisampling:i=0,frameBufferType:r}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,s,r,i),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new yt,this.depthTexture=null,this.passes=[],this.timer=new zt,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const t=this.inputBuffer,s=this.multisampling;s>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):s!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const t=e.getSize(new E),s=e.getContext().getContextAttributes().alpha,i=this.inputBuffer.texture.type;i===z&&N(e)===g&&(U(this.inputBuffer.texture,g),U(this.outputBuffer.texture,g),this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(t.width,t.height);for(const r of this.passes)r.initialize(e,s,i)}}replaceRenderer(e,t=!0){const s=this.renderer,i=s.domElement.parentNode;return this.setRenderer(e),t&&i!==null&&(i.removeChild(s.domElement),i.appendChild(e.domElement)),s}createDepthTexture(){const e=this.depthTexture=new Ce;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=Ae,e.type=ze):e.type=Ie,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,t,s,i){const r=this.renderer,n=r===null?new E:r.getDrawingBufferSize(new E),a={minFilter:X,magFilter:X,stencilBuffer:t,depthBuffer:e,type:s},o=new R(n.width,n.height,a);return i>0&&(o.ignoreDepthForMultisampleCopy=!1,o.samples=i),s===z&&N(r)===g&&U(o.texture,g),o.texture.name="EffectComposer.Buffer",o.texture.generateMipmaps=!1,o}setMainScene(e){for(const t of this.passes)t.mainScene=e}setMainCamera(e){for(const t of this.passes)t.mainCamera=e}addPass(e,t){const s=this.passes,i=this.renderer,r=i.getDrawingBufferSize(new E),n=i.getContext().getContextAttributes().alpha,a=this.inputBuffer.texture.type;if(e.setRenderer(i),e.setSize(r.width,r.height),e.initialize(i,n,a),this.autoRenderToScreen&&(s.length>0&&(s[s.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?s.splice(t,0,e):s.push(e),this.autoRenderToScreen&&(s[s.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const o=this.createDepthTexture();for(e of s)e.setDepthTexture(o)}else e.setDepthTexture(this.depthTexture)}removePass(e){const t=this.passes,s=t.indexOf(e);if(s!==-1&&t.splice(s,1).length>0){if(this.depthTexture!==null){const n=(o,l)=>o||l.needsDepthTexture;t.reduce(n,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&s===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const t=this.renderer,s=this.copyPass;let i=this.inputBuffer,r=this.outputBuffer,n=!1,a,o,l;e===void 0&&(this.timer.update(),e=this.timer.delta);for(const c of this.passes)c.enabled&&(c.render(t,i,r,e,n),c.needsSwap&&(n&&(s.renderToScreen=c.renderToScreen,a=t.getContext(),o=t.state.buffers.stencil,o.setFunc(a.NOTEQUAL,1,4294967295),s.render(t,i,r,e,n),o.setFunc(a.EQUAL,1,4294967295)),l=i,i=r,r=l),c instanceof Pt?n=!0:c instanceof wt&&(n=!1))}setSize(e,t,s){const i=this.renderer,r=i.getSize(new E);(e===void 0||t===void 0)&&(e=r.width,t=r.height),(r.width!==e||r.height!==t)&&i.setSize(e,t,s);const n=i.getDrawingBufferSize(new E);this.inputBuffer.setSize(n.width,n.height),this.outputBuffer.setSize(n.width,n.height);for(const a of this.passes)a.setSize(n.width,n.height)}reset(){const e=this.timer.autoReset;this.dispose(),this.autoRenderToScreen=!0,this.timer.autoReset=e}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},Ht=class{constructor(){this.shaderParts=new Map([[f.FRAGMENT_HEAD,null],[f.FRAGMENT_MAIN_UV,null],[f.FRAGMENT_MAIN_IMAGE,null],[f.VERTEX_HEAD,null],[f.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=C.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Y}},Nt=class extends Set{constructor(e,t=10){super(),this.l=t,this.exclusive=!1,e!==void 0&&this.set(e)}get layer(){return this.l}set layer(e){const t=this.l;for(const s of this)s.layers.disable(t),s.layers.enable(e);this.l=e}getLayer(){return this.layer}setLayer(e){this.layer=e}isExclusive(){return this.exclusive}setExclusive(e){this.exclusive=e}clear(){const e=this.layer;for(const t of this)t.layers.disable(e);return super.clear()}set(e){this.clear();for(const t of e)this.add(t);return this}indexOf(e){return this.has(e)?0:-1}add(e){return this.exclusive?e.layers.set(this.layer):e.layers.enable(this.layer),super.add(e)}delete(e){return this.has(e)&&e.layers.disable(this.layer),super.delete(e)}toggle(e){let t;return this.has(e)?(this.delete(e),t=!1):(this.add(e),t=!0),t}setVisible(e){for(const t of this)e?t.layers.enable(0):t.layers.disable(0);return this}},Ft="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Ot="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",Lt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",Gt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",kt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",Vt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",Wt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",Kt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Xt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",Zt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Yt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",qt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",$t="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Qt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",jt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Jt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",es="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",ts="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",ss="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",is="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",rs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",ns="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",as="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",os="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",ls="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",hs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",us="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",cs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",ds="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",fs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",ps="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",vs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",ms=new Map([[d.ADD,Ft],[d.ALPHA,Ot],[d.AVERAGE,Lt],[d.COLOR,Gt],[d.COLOR_BURN,kt],[d.COLOR_DODGE,Vt],[d.DARKEN,Wt],[d.DIFFERENCE,Kt],[d.DIVIDE,Xt],[d.DST,null],[d.EXCLUSION,Zt],[d.HARD_LIGHT,Yt],[d.HARD_MIX,qt],[d.HUE,$t],[d.INVERT,Qt],[d.INVERT_RGB,jt],[d.LIGHTEN,Jt],[d.LINEAR_BURN,es],[d.LINEAR_DODGE,ts],[d.LINEAR_LIGHT,ss],[d.LUMINOSITY,is],[d.MULTIPLY,rs],[d.NEGATION,ns],[d.NORMAL,as],[d.OVERLAY,os],[d.PIN_LIGHT,ls],[d.REFLECT,hs],[d.SATURATION,us],[d.SCREEN,cs],[d.SOFT_LIGHT,ds],[d.SRC,fs],[d.SUBTRACT,ps],[d.VIVID_LIGHT,vs]]),gs=class extends ae{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new p(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return ms.get(this.blendFunction)}},Ss=class extends ae{constructor(e,t,{attributes:s=C.NONE,blendFunction:i=d.NORMAL,defines:r=new Map,uniforms:n=new Map,extensions:a=null,vertexShader:o=null}={}){super(),this.name=e,this.renderer=null,this.attributes=s,this.fragmentShader=t,this.vertexShader=o,this.defines=r,this.uniforms=n,this.extensions=a,this.blendMode=new gs(i),this.blendMode.addEventListener("change",l=>this.setChanged()),this._inputColorSpace=Y,this._outputColorSpace=Re}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=H){}update(e,t,s){}setSize(e,t){}initialize(e,t,s){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof R||t instanceof we||t instanceof be||t instanceof w)&&this[e].dispose()}}},xs=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`,Ts=class extends Ss{constructor({blendFunction:e=d.SCREEN,luminanceThreshold:t=.9,luminanceSmoothing:s=.025,mipmapBlur:i=!1,intensity:r=1,radius:n=.85,levels:a=8,kernelSize:o=le.LARGE,resolutionScale:l=.5,width:c=y.AUTO_SIZE,height:m=y.AUTO_SIZE,resolutionX:v=c,resolutionY:h=m}={}){super("BloomEffect",xs,{blendFunction:e,uniforms:new Map([["map",new p(null)],["intensity",new p(r)]])}),this.renderTarget=new R(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new Bt({kernelSize:o}),this.luminancePass=new Ut({colorOutput:!0}),this.luminanceMaterial.threshold=t,this.luminanceMaterial.smoothing=s,this.mipmapBlurPass=new Dt,this.mipmapBlurPass.enabled=i,this.mipmapBlurPass.radius=n,this.mipmapBlurPass.levels=a,this.uniforms.get("map").value=i?this.mipmapBlurPass.texture:this.renderTarget.texture;const u=this.resolution=new y(this,v,h,l);u.addEventListener("change",b=>this.setSize(u.baseWidth,u.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(e){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}getIntensity(){return this.intensity}setIntensity(e){this.intensity=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}update(e,t,s){const i=this.renderTarget,r=this.luminancePass;r.enabled?(r.render(e,t),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,r.renderTarget):this.blurPass.render(e,r.renderTarget,i)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,t):this.blurPass.render(e,t,i)}setSize(e,t){const s=this.resolution;s.setBaseSize(e,t),this.renderTarget.setSize(s.width,s.height),this.blurPass.resolution.copy(s),this.luminancePass.setSize(e,t),this.mipmapBlurPass.setSize(e,t)}initialize(e,t,s){this.blurPass.initialize(e,t,s),this.luminancePass.initialize(e,t,s),this.mipmapBlurPass.initialize(e,t,s),s!==void 0&&(this.renderTarget.texture.type=s,N(e)===g&&U(this.renderTarget.texture,g))}};new S;new He;new B;new S;new S;var Es=class extends Ts{constructor(e,t,s){super(s),this.setAttributes(this.getAttributes()|C.DEPTH),this.camera=t,this.depthPass=new bt(e,t),this.clearPass=new he(!0,!1,!1),this.clearPass.overrideClearColor=new B(0),this.depthMaskPass=new Ct(new ht);const i=this.depthMaskMaterial;i.copyCameraSettings(t),i.depthBuffer1=this.depthPass.texture,i.depthPacking1=Te,i.depthMode=te,this.renderTargetMasked=new R(1,1,{depthBuffer:!1}),this.renderTargetMasked.texture.name="Bloom.Masked",this.selection=new Nt,this.selection.layer=11,this._inverted=!1,this._ignoreBackground=!1}set mainScene(e){this.depthPass.mainScene=e}set mainCamera(e){this.camera=e,this.depthPass.mainCamera=e,this.depthMaskMaterial.copyCameraSettings(e)}getSelection(){return this.selection}get depthMaskMaterial(){return this.depthMaskPass.fullscreenMaterial}get inverted(){return this._inverted}set inverted(e){this._inverted=e,this.depthMaskMaterial.depthMode=e?Ee:te}isInverted(){return this.inverted}setInverted(e){this.inverted=e}get ignoreBackground(){return this._ignoreBackground}set ignoreBackground(e){this._ignoreBackground=e,this.depthMaskMaterial.maxDepthStrategy=e?O.DISCARD_MAX_DEPTH:O.KEEP_MAX_DEPTH}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}setDepthTexture(e,t=H){this.depthMaskMaterial.depthBuffer0=e,this.depthMaskMaterial.depthPacking0=t}update(e,t,s){const i=this.camera,r=this.selection,n=this.inverted;let a=t;if(this.ignoreBackground||!n||r.size>0){const o=i.layers.mask;i.layers.set(r.layer),this.depthPass.render(e),i.layers.mask=o,a=this.renderTargetMasked,this.clearPass.render(e,a),this.depthMaskPass.render(e,t,a)}super.update(e,a,s)}setSize(e,t){super.setSize(e,t),this.renderTargetMasked.setSize(e,t),this.depthPass.setSize(e,t)}initialize(e,t,s){super.initialize(e,t,s),this.clearPass.initialize(e,t,s),this.depthPass.initialize(e,t,s),this.depthMaskPass.initialize(e,t,s),s!==void 0&&(this.renderTargetMasked.texture.type=s,N(e)===g&&U(this.renderTargetMasked.texture,g))}};class Ms{constructor(){this.renderer,this.composer,this.effect,this.selection,this.scene,this.camera,this.directionalLight,this.ambientLight,this.controls,this.clock}init(t,s){this.renderer=new Ke({powerPreference:"high-performance",antialias:!1,stencil:!1,depth:!1}),this.renderer.setClearColor(new B(t.clearColor)),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),document.getElementById("webgl").appendChild(this.renderer.domElement),this.scene=new se,this.camera=new re(s.fov,window.innerWidth/window.innerHeight,s.near,s.far),this.camera.position.set(s.pos.x,s.pos.y,s.pos.z),this.effect=new Es(this.scene,this.camera,{blendFunction:d.ADD,mipmapBlur:!0,luminanceThreshold:.15,luminanceSmoothing:.44,intensity:10}),this.effect.outputColorSpace="srgb",this.selection=this.effect.selection,this.composer=new It(this.renderer),this.composer.addPass(new Ue(this.scene,this.camera)),this.composer.addPass(new _t(this.camera,this.effect)),this.clock=new Xe}resize(){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}}function ys(){const[e,t]=Ye("default");return{status:e,setStatus:t}}const ie=Ze(ys);class ws{constructor(){this.group=new _,this.pivot=new _,this.head=new _,this.propellers=new _}create(t){return new Promise(s=>{this.group.position.z=-2,t.add(this.group),this.pivot.userData.theta=0,this.group.add(this.pivot),this.head.position.z=3,this.pivot.add(this.head),this.head.add(this.propellers);const i=new _,r=this.createCircle(new B("skyblue"));this.head.add(i);for(let h=-1;h<2;h++){const u=r.clone();u.position.z=h*.06,u.rotation.x=(Math.random()*2-1)*Math.PI*.01,u.rotation.y=(Math.random()*2-1)*Math.PI*.01,i.add(u)}const n=new _,a=this.createArc(new B("skyblue"));this.head.add(n);for(let h=0;h<12;h++){const u=a.clone();u.rotation.z=Math.PI*2*(h/12),n.add(u)}const o=new _,l=this.createCircle(new B(16382352));this.head.add(o);for(let h=0;h<6;h++){const u=l.clone();u.position.set(0,0,h*-.45+-1.4),u.scale.set(.4+-.2*(h/6),.4+-.1*(h/6),2),u.rotation.x=(Math.random()*2-1)*Math.PI*.02,u.rotation.y=(Math.random()*2-1)*Math.PI*.02,o.add(u)}const c=this.createPropeller();for(let h=0;h<5;h++){const u=new _;for(let b=-1;b<2;b++){const x=c.clone();x.scale.z=1.5,x.position.z=b*.01,x.rotation.z=(Math.random()*2-1)*Math.PI*.02,u.add(x)}u.rotation.z=Math.PI*2*(h/5)-Math.PI*.1,this.propellers.add(u)}const m=new _;this.group.add(m);const v=this.createCircle(new B("pink"));v.rotation.x=Math.PI*.5;for(let h=0;h<28;h++){const u=v.clone();u.rotation.x+=(Math.random()*2-1)*Math.PI*.03,u.rotation.z+=(Math.random()*2-1)*Math.PI*.03,u.position.y=-1+h*-.18,h<24?u.scale.set(.1,.1,2):u.scale.set(.5,.5,1),m.add(u)}s()})}createArc(t=new S){const s=[new S(-3.2,0,0),new S(-3,0,-2),new S(3,0,-2),new S(3.2,0,0)],i=new fe(...s);i.getPoints(32);const r=new pe(i,32,.005,8,!1),n=new Q({color:t});return new K(r,n)}createCircle(t=new S){const s=new qe(3.2,.005,6,32),i=new Q({color:t});return new K(s,i)}createPropeller(t=new S){const s=[new S(-.5,.2,0),new S(-3.7,1.6,0),new S(3.2,5.1,0),new S(.4,.6,0)],i=new fe(...s),r=i.getPoints(32);r.unshift(new S(0,0,0)),r.push(new S(0,0,0));const n=new pe(i,32,.003,8,!0).rotateY(Math.PI*.1),a=new Q({color:t});return new K(n,a)}async switchOn(t){t.renderer.setClearColor(3155751),this.group.traverse(s=>{s.isMesh&&setTimeout(()=>{t.selection.add(s)},Math.random()*1600)}),await this.timeout(2e3),ie.setStatus("running"),await this.timeout(4e3),this.switchOff(t)}async switchOff(t){ie.setStatus("stop"),await this.timeout(1e3),this.group.traverse(s=>{s.isMesh&&setTimeout(()=>{t.selection.delete(s)},Math.random()*1600)}),await this.timeout(4e3),this.switchOn(t)}rotateHead(t){this.pivot.userData.theta+=t,this.pivot.rotation.y=Math.sin(this.pivot.userData.theta*.5)}rotateFan(t){this.propellers.rotation.z-=t*2}async timeout(t=1e3){return new Promise(s=>{setTimeout(s,t)})}}class bs{constructor(){this.items={}}create(t){return new Promise(s=>{this.items.fan=new ws;const i=this.items.fan.create(t);Promise.all([i]).then(s)})}getItems(){return this.items}createLights(t){this.items.pointLight=new $e(16777215,2,20),this.items.pointLight.position.set(-1,1,1),t.add(this.items.pointLight),this.items.ambientLight=new Qe(16777215,.2),t.add(this.items.ambientLight)}}function Rs(e,t){const s=new Je,i={},r=new je(e.camera,e.renderer.domElement);i.resetControl=()=>{r.reset()},s.add(i,"resetControl").name("reset OrbitControls"),i.clearColor=0,s.addColor(i,"clearColor").onChange(n=>{e.renderer.setClearColor(n)}),s.add(e.effect.luminancePass.fullscreenMaterial,"threshold",0,1,.01),s.add(e.effect.luminancePass.fullscreenMaterial,"smoothing",0,1,.01),i.bloomIntensity=1,s.add(i,"bloomIntensity",0,10,.1).onChange(n=>{e.effect.uniforms.get("intensity").value=n})}const A=new Ms,Se=new bs;let Z,ee=0,xe=0,L=0;window.addEventListener("load",()=>{A.init(_s,Bs),Se.create(A.scene).then(()=>{Z=Se.getItems(),Us(),Pe(),A.clock.start()})});window.addEventListener("resize",()=>{A.resize()});const _s={clearColor:16771917},Bs={fov:60,near:.1,far:30,pos:{x:0,y:-.5,z:10}};function Us(){Rs(A),Z.fan.switchOn(A)}async function Ps(){switch(ie.status()){case"running":Z.fan.rotateHead(L),Z.fan.rotateFan(L);break}}function Pe(){requestAnimationFrame(Pe),ee=A.clock.getElapsedTime(),L=ee-xe,L=Math.max(0,Math.min(L,.2)),xe=ee,Ps(),A.composer.render()}
