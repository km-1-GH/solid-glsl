import"./modulepreload-polyfill-3cfb730f.js";import{G as Q}from"./lil-gui.esm-b4f18ba3.js";class N{static loadFile(t){return new Promise((e,n)=>{fetch(t).then(i=>i.text()).then(i=>{e(i)}).catch(i=>{n(i)})})}static createWebGLContext(t){const e=t.getContext("webgl");if(e==null)throw new Error("webgl not supported");return e}static createShaderObject(t,e,n){const i=t.createShader(n);if(t.shaderSource(i,e),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS))return i;throw new Error(t.getShaderInfoLog(i))}static createProgramObject(t,e,n){const i=t.createProgram();if(t.attachShader(i,e),t.attachShader(i,n),t.linkProgram(i),t.deleteShader(e),t.deleteShader(n),t.getProgramParameter(i,t.LINK_STATUS))return t.useProgram(i),i;throw new Error(t.getProgramInfoLog(i))}static createVBO(t,e){const n=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,n),t.bufferData(t.ARRAY_BUFFER,new Float32Array(e),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),n}static createIBO(t,e){const n=t.createBuffer();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Int16Array(e),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),n}static enableBuffer(t,e,n,i,s){for(let r=0;r<e.length;++r)t.bindBuffer(t.ARRAY_BUFFER,e[r]),t.enableVertexAttribArray(n[r]),t.vertexAttribPointer(n[r],i[r],t.FLOAT,!1,0,0);s!=null&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,s)}}class H{static get Vec2(){return k}static get Vec3(){return K}static get Mat4(){return W}static get Qtn(){return $}}let k=class _{static create(t=0,e=0){const n=new Float32Array(2);return n[0]=t,n[1]=e,n}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}static normalize(t){const e=_.create(),n=_.length(t);if(n>0){const i=1/n;e[0]=t[0]*i,e[1]=t[1]*i}return e}static dot(t,e){return t[0]*e[0]+t[1]*e[1]}static cross(t,e){return _.create(),t[0]*e[1]-t[1]*e[0]}},K=class X{static create(t=0,e=0,n=0){const i=new Float32Array(3);return i[0]=t,i[1]=e,i[2]=n,i}static length(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}static normalize(t){const e=X.create(),n=X.length(t);if(n>0){const i=1/n;e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i}return e}static dot(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}static cross(t,e){return X.create(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])}static faceNormal(t,e,n){const i=X.create(e[0]-t[0],e[1]-t[1],e[2]-t[2]),s=X.create(n[0]-t[0],n[1]-t[1],n[2]-t[2]),r=X.create(i[1]*s[2]-i[2]*s[1],i[2]*s[0]-i[0]*s[2],i[0]*s[1]-i[1]*s[0]);return X.normalize(r)}},W=class F{static create(){return new Float32Array(16)}static identity(t){const e=t??F.create();return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}static multiply(t,e,n){const i=n??F.create(),s=t[0],r=t[1],o=t[2],a=t[3],u=t[4],c=t[5],l=t[6],h=t[7],f=t[8],g=t[9],p=t[10],d=t[11],y=t[12],A=t[13],x=t[14],b=t[15],E=e[0],P=e[1],M=e[2],w=e[3],I=e[4],T=e[5],m=e[6],L=e[7],S=e[8],D=e[9],C=e[10],v=e[11],V=e[12],O=e[13],Z=e[14],G=e[15];return i[0]=E*s+P*u+M*f+w*y,i[1]=E*r+P*c+M*g+w*A,i[2]=E*o+P*l+M*p+w*x,i[3]=E*a+P*h+M*d+w*b,i[4]=I*s+T*u+m*f+L*y,i[5]=I*r+T*c+m*g+L*A,i[6]=I*o+T*l+m*p+L*x,i[7]=I*a+T*h+m*d+L*b,i[8]=S*s+D*u+C*f+v*y,i[9]=S*r+D*c+C*g+v*A,i[10]=S*o+D*l+C*p+v*x,i[11]=S*a+D*h+C*d+v*b,i[12]=V*s+O*u+Z*f+G*y,i[13]=V*r+O*c+Z*g+G*A,i[14]=V*o+O*l+Z*p+G*x,i[15]=V*a+O*h+Z*d+G*b,i}static scale(t,e,n){const i=n??F.create();return i[0]=t[0]*e[0],i[1]=t[1]*e[0],i[2]=t[2]*e[0],i[3]=t[3]*e[0],i[4]=t[4]*e[1],i[5]=t[5]*e[1],i[6]=t[6]*e[1],i[7]=t[7]*e[1],i[8]=t[8]*e[2],i[9]=t[9]*e[2],i[10]=t[10]*e[2],i[11]=t[11]*e[2],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15],i}static translate(t,e,n){const i=n??F.create();return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11],i[12]=t[0]*e[0]+t[4]*e[1]+t[8]*e[2]+t[12],i[13]=t[1]*e[0]+t[5]*e[1]+t[9]*e[2]+t[13],i[14]=t[2]*e[0]+t[6]*e[1]+t[10]*e[2]+t[14],i[15]=t[3]*e[0]+t[7]*e[1]+t[11]*e[2]+t[15],i}static rotate(t,e,n,i){let s=i??F.create();const r=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);if(!r)return null;let o=n[0],a=n[1],u=n[2];if(r!=1){const O=1/r;o*=O,a*=O,u*=O}const c=Math.sin(e),l=Math.cos(e),h=1-l,f=t[0],g=t[1],p=t[2],d=t[3],y=t[4],A=t[5],x=t[6],b=t[7],E=t[8],P=t[9],M=t[10],w=t[11],I=o*o*h+l,T=a*o*h+u*c,m=u*o*h-a*c,L=o*a*h-u*c,S=a*a*h+l,D=u*a*h+o*c,C=o*u*h+a*c,v=a*u*h-o*c,V=u*u*h+l;return e?t!=s&&(s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15]):s=t,s[0]=f*I+y*T+E*m,s[1]=g*I+A*T+P*m,s[2]=p*I+x*T+M*m,s[3]=d*I+b*T+w*m,s[4]=f*L+y*S+E*D,s[5]=g*L+A*S+P*D,s[6]=p*L+x*S+M*D,s[7]=d*L+b*S+w*D,s[8]=f*C+y*v+E*V,s[9]=g*C+A*v+P*V,s[10]=p*C+x*v+M*V,s[11]=d*C+b*v+w*V,s}static lookAt(t,e,n,i){const s=i??F.create(),r=t[0],o=t[1],a=t[2],u=e[0],c=e[1],l=e[2],h=n[0],f=n[1],g=n[2];if(r==u&&o==c&&a==l)return F.identity(s);let p,d,y,A,x,b,E,P,M,w;return E=r-u,P=o-c,M=a-l,w=1/Math.sqrt(E*E+P*P+M*M),E*=w,P*=w,M*=w,p=f*M-g*P,d=g*E-h*M,y=h*P-f*E,w=Math.sqrt(p*p+d*d+y*y),w?(w=1/w,p*=w,d*=w,y*=w):(p=0,d=0,y=0),A=P*y-M*d,x=M*p-E*y,b=E*d-P*p,w=Math.sqrt(A*A+x*x+b*b),w?(w=1/w,A*=w,x*=w,b*=w):(A=0,x=0,b=0),s[0]=p,s[1]=A,s[2]=E,s[3]=0,s[4]=d,s[5]=x,s[6]=P,s[7]=0,s[8]=y,s[9]=b,s[10]=M,s[11]=0,s[12]=-(p*r+d*o+y*a),s[13]=-(A*r+x*o+b*a),s[14]=-(E*r+P*o+M*a),s[15]=1,s}static perspective(t,e,n,i,s){const r=s??F.create(),o=n*Math.tan(t*Math.PI/360),u=o*e*2,c=o*2,l=i-n;return r[0]=n*2/u,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=n*2/c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=-(i+n)/l,r[11]=-1,r[12]=0,r[13]=0,r[14]=-(i*n*2)/l,r[15]=0,r}static ortho(t,e,n,i,s,r,o){const a=o??F.create(),u=e-t,c=n-i,l=r-s;return a[0]=2/u,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/c,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=-2/l,a[11]=0,a[12]=-(t+e)/u,a[13]=-(n+i)/c,a[14]=-(r+s)/l,a[15]=1,a}static transpose(t,e){const n=e??F.create();return n[0]=t[0],n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=t[1],n[5]=t[5],n[6]=t[9],n[7]=t[13],n[8]=t[2],n[9]=t[6],n[10]=t[10],n[11]=t[14],n[12]=t[3],n[13]=t[7],n[14]=t[11],n[15]=t[15],n}static inverse(t,e){const n=e??F.create(),i=t[0],s=t[1],r=t[2],o=t[3],a=t[4],u=t[5],c=t[6],l=t[7],h=t[8],f=t[9],g=t[10],p=t[11],d=t[12],y=t[13],A=t[14],x=t[15],b=i*u-s*a,E=i*c-r*a,P=i*l-o*a,M=s*c-r*u,w=s*l-o*u,I=r*l-o*c,T=h*y-f*d,m=h*A-g*d,L=h*x-p*d,S=f*A-g*y,D=f*x-p*y,C=g*x-p*A,v=1/(b*C-E*D+P*S+M*L-w*m+I*T);return n[0]=(u*C-c*D+l*S)*v,n[1]=(-s*C+r*D-o*S)*v,n[2]=(y*I-A*w+x*M)*v,n[3]=(-f*I+g*w-p*M)*v,n[4]=(-a*C+c*L-l*m)*v,n[5]=(i*C-r*L+o*m)*v,n[6]=(-d*I+A*P-x*E)*v,n[7]=(h*I-g*P+p*E)*v,n[8]=(a*D-u*L+l*T)*v,n[9]=(-i*D+s*L-o*T)*v,n[10]=(d*w-y*P+x*b)*v,n[11]=(-h*w+f*P-p*b)*v,n[12]=(-a*S+u*m-c*T)*v,n[13]=(i*S-s*m+r*T)*v,n[14]=(-d*M+y*E-A*b)*v,n[15]=(h*M-f*E+g*b)*v,n}static toVecIV(t,e){const n=t[0],i=t[1],s=t[2],r=t[3],o=t[4],a=t[5],u=t[6],c=t[7],l=t[8],h=t[9],f=t[10],g=t[11],p=t[12],d=t[13],y=t[14],A=t[15],x=e[0],b=e[1],E=e[2],P=e[3],M=new Float32Array(4);return M[0]=x*n+b*o+E*l+P*p,M[1]=x*i+b*a+E*h+P*d,M[2]=x*s+b*u+E*f+P*y,M[3]=x*r+b*c+E*g+P*A,M}static screenPositionFromMvp(t,e,n,i){const s=n*.5,r=i*.5,o=F.toVecIV(t,[e[0],e[1],e[2],1]);if(o[3]<=0)return[NaN,NaN];o[0]/=o[3],o[1]/=o[3],o[2]/=o[3];const a=k.create();return a[0]=s+o[0]*s,a[1]=r-o[1]*r,a}},$=class R{static create(){return new Float32Array(4)}static identity(t){const e=t??R.create();return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}static inverse(t,e){const n=e??R.create();return n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],n[3]=t[3],n}static normalize(t){const e=R.create(),n=t[0],i=t[1],s=t[2],r=Math.sqrt(n*n+i*i+s*s);if(r>0){const o=1/r;e[0]=n*o,e[1]=i*o,e[2]=s*o}return e}static multiply(t,e,n){const i=n??R.create(),s=t[0],r=t[1],o=t[2],a=t[3],u=e[0],c=e[1],l=e[2],h=e[3];return i[0]=s*h+a*u+r*l-o*c,i[1]=r*h+a*c+o*u-s*l,i[2]=o*h+a*l+s*c-r*u,i[3]=a*h-s*u-r*c-o*l,i}static rotate(t,e,n){const i=n??R.create();let s=e[0],r=e[1],o=e[2];const a=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);if(a!==0){const c=1/a;s*=c,r*=c,o*=c}const u=Math.sin(t*.5);return i[0]=s*u,i[1]=r*u,i[2]=o*u,i[3]=Math.cos(t*.5),i}static toVecIII(t,e,n){const i=n??K.create(),s=R.create(),r=R.create(),o=R.create();return R.inverse(e,o),s[0]=t[0],s[1]=t[1],s[2]=t[2],R.multiply(o,s,r),R.multiply(r,e,o),i[0]=o[0],i[1]=o[1],i[2]=o[2],i}static toMatIV(t,e){const n=e??W.create(),i=t[0],s=t[1],r=t[2],o=t[3],a=i+i,u=s+s,c=r+r,l=i*a,h=i*u,f=i*c,g=s*u,p=s*c,d=r*c,y=o*a,A=o*u,x=o*c;return n[0]=1-(g+d),n[1]=h-x,n[2]=f+A,n[3]=0,n[4]=h+x,n[5]=1-(l+d),n[6]=p-y,n[7]=0,n[8]=f-A,n[9]=p+y,n[10]=1-(l+g),n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}static slerp(t,e,n,i){const s=i??R.create(),r=t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3];let o=1-r*r;if(o<=0)s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3];else if(o=Math.sqrt(o),Math.abs(o)<1e-4)s[0]=t[0]*.5+e[0]*.5,s[1]=t[1]*.5+e[1]*.5,s[2]=t[2]*.5+e[2]*.5,s[3]=t[3]*.5+e[3]*.5;else{const a=Math.acos(r),u=a*n,c=Math.sin(a-u)/o,l=Math.sin(u)/o;s[0]=t[0]*c+e[0]*l,s[1]=t[1]*c+e[1]*l,s[2]=t[2]*c+e[2]*l,s[3]=t[3]*c+e[3]*l}return s}};class J{static plane(t,e,n){const i=t/2,s=e/2,r=[-i,s,0,i,s,0,-i,-s,0,i,-s,0],o=[0,0,1,0,0,1,0,0,1,0,0,1],a=[n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3],n[0],n[1],n[2],n[3]];return{position:r,normal:o,color:a,texCoord:[0,0,1,0,0,1,1,1],index:[0,2,1,1,2,3]}}static circle(t,e,n){const i=[],s=[],r=[],o=[],a=[];i.push(0,0,0),s.push(0,0,1),r.push(n[0],n[1],n[2],n[3]),o.push(.5,.5);let u=0;for(let c=0;c<t;c++){const l=Math.PI*2/t*c,h=Math.cos(l),f=Math.sin(l);i.push(h*e,f*e,0),s.push(0,0,1),r.push(n[0],n[1],n[2],n[3]),o.push((h+1)*.5,1-(f+1)*.5),c===t-1?a.push(0,u+1,1):a.push(0,u+1,u+2),++u}return{position:i,normal:s,color:r,texCoord:o,index:a}}static cube(t,e){const n=t*.5,i=[-n,-n,n,n,-n,n,n,n,n,-n,n,n,-n,-n,-n,-n,n,-n,n,n,-n,n,-n,-n,-n,n,-n,-n,n,n,n,n,n,n,n,-n,-n,-n,-n,n,-n,-n,n,-n,n,-n,-n,n,n,-n,-n,n,n,-n,n,n,n,n,-n,n,-n,-n,-n,-n,-n,n,-n,n,n,-n,n,-n],s=1/Math.sqrt(3),r=[-s,-s,s,s,-s,s,s,s,s,-s,s,s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s,-s,-s,s,-s,-s,s,s,s,s,s,s,s,-s,-s,-s,-s,s,-s,-s,s,-s,s,-s,-s,s,s,-s,-s,s,s,-s,s,s,s,s,-s,s,-s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s],o=[];for(let c=0;c<i.length/3;c++)o.push(e[0],e[1],e[2],e[3]);return{position:i,normal:r,color:o,texCoord:[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],index:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]}}static cone(t,e,n,i){const s=[],r=[],o=[],a=[],u=[],c=n/2;s.push(0,-c,0),r.push(0,-1,0),o.push(i[0],i[1],i[2],i[3]),a.push(.5,.5);let l=0;for(let h=0;h<=t;h++){const f=Math.PI*2/t*h,g=Math.cos(f),p=Math.sin(f);s.push(g*e,-c,p*e,g*e,-c,p*e),r.push(0,-1,0,g,0,p),o.push(i[0],i[1],i[2],i[3],i[0],i[1],i[2],i[3]),a.push((g+1)*.5,1-(p+1)*.5,(g+1)*.5,1-(p+1)*.5),h!==t&&(u.push(0,l+1,l+3),u.push(l+4,l+2,t*2+3)),l+=2}return s.push(0,c,0),r.push(0,1,0),o.push(i[0],i[1],i[2],i[3]),a.push(.5,.5),{position:s,normal:r,color:o,texCoord:a,index:u}}static cylinder(t,e,n,i,s){const r=[],o=[],a=[],u=[],c=[],l=i/2;r.push(0,l,0,0,-l,0),o.push(0,1,0,0,-1,0),a.push(s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3]),u.push(.5,.5,.5,.5);let h=2;for(let f=0;f<=t;f++){const g=Math.PI*2/t*f,p=Math.cos(g),d=Math.sin(g);r.push(p*e,l,d*e,p*e,l,d*e,p*n,-l,d*n,p*n,-l,d*n),o.push(0,1,0,p,0,d,0,-1,0,p,0,d),a.push(s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3],s[0],s[1],s[2],s[3]),u.push((p+1)*.5,1-(d+1)*.5,1-f/t,0,(p+1)*.5,1-(d+1)*.5,1-f/t,1),f!==t&&c.push(0,h+4,h,1,h+2,h+6,h+5,h+7,h+1,h+1,h+7,h+3),h+=4}return{position:r,normal:o,color:a,texCoord:u,index:c}}static sphere(t,e,n,i){const s=[],r=[],o=[],a=[],u=[];for(let c=0;c<=t;c++){const l=Math.PI/t*c,h=Math.cos(l),f=Math.sin(l);for(let g=0;g<=e;g++){const p=Math.PI*2/e*g,d=f*n*Math.cos(p),y=h*n,A=f*n*Math.sin(p),x=f*Math.cos(p),b=f*Math.sin(p);s.push(d,y,A),r.push(x,h,b),o.push(i[0],i[1],i[2],i[3]),a.push(1-1/e*g,1/t*c)}}for(let c=0;c<t;c++)for(let l=0;l<e;l++){const h=(e+1)*c+l;u.push(h,h+1,h+e+2),u.push(h,h+e+2,h+e+1)}return{position:s,normal:r,color:o,texCoord:a,index:u}}static torus(t,e,n,i,s){const r=[],o=[],a=[],u=[],c=[];for(let l=0;l<=t;l++){const h=Math.PI*2/t*l,f=Math.cos(h),g=Math.sin(h);for(let p=0;p<=e;p++){const d=Math.PI*2/e*p,y=(f*n+i)*Math.cos(d),A=g*n,x=(f*n+i)*Math.sin(d),b=f*Math.cos(d),E=f*Math.sin(d),P=1/e*p;let M=1/t*l+.5;M>1&&(M-=1),M=1-M,r.push(y,A,x),o.push(b,g,E),a.push(s[0],s[1],s[2],s[3]),u.push(P,M)}}for(let l=0;l<t;l++)for(let h=0;h<e;h++){const f=(e+1)*l+h;c.push(f,f+e+1,f+1),c.push(f+e+1,f+e+2,f+1)}return{position:r,normal:o,color:a,texCoord:u,index:c}}static icosahedron(t,e){const n=(1+Math.sqrt(5))/2,i=n*t,s=Math.sqrt(1+n*n),r=[1/s,n/s],o=[-t,i,0,t,i,0,-t,-i,0,t,-i,0,0,-t,i,0,t,i,0,-t,-i,0,t,-i,i,0,-t,i,0,t,-i,0,-t,-i,0,t],a=[-r[0],r[1],0,r[0],r[1],0,-r[0],-r[1],0,r[0],-r[1],0,0,-r[0],r[1],0,r[0],r[1],0,-r[0],-r[1],0,r[0],-r[1],r[1],0,-r[0],r[1],0,r[0],-r[1],0,-r[0],-r[1],0,r[0]],u=[e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3]],c=[];for(let h=0,f=a.length;h<f;h+=3){const g=(Math.atan2(a[h+2],-a[h])+Math.PI)/(Math.PI*2),p=1-(a[h+1]+1)/2;c.push(g,p)}return{position:o,normal:a,color:u,texCoord:c,index:[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}}}const j=H.Vec2,U=H.Vec3,q=H.Mat4,B=H.Qtn;class Y{static get DEFAULT_DISTANCE(){return 5}static get DEFAULT_MIN_DISTANCE(){return 1}static get DEFAULT_MAX_DISTANCE(){return 10}static get DEFAULT_MOVE_SCALE(){return 2}constructor(t,e={}){this.target=t,this.distance=e.distance||Y.DEFAULT_DISTANCE,this.minDistance=e.min||Y.DEFAULT_MIN_DISTANCE,this.maxDistance=e.max||Y.DEFAULT_MAX_DISTANCE,this.moveScale=e.move||Y.DEFAULT_MOVE_SCALE,this.position=U.create(0,0,this.distance),this.center=U.create(0,0,0),this.upDirection=U.create(0,1,0),this.defaultPosition=U.create(0,0,this.distance),this.defaultCenter=U.create(0,0,0),this.defaultUpDirection=U.create(0,1,0),this.movePosition=U.create(0,0,0),this.rotateX=0,this.rotateY=0,this.scale=0,this.isDown=!1,this.prevPosition=j.create(0,0),this.offsetPosition=j.create(0,0),this.qt=B.create(),this.qtx=B.create(),this.qty=B.create(),this.mouseInteractionStart=this.mouseInteractionStart.bind(this),this.mouseInteractionMove=this.mouseInteractionMove.bind(this),this.mouseInteractionEnd=this.mouseInteractionEnd.bind(this),this.wheelScroll=this.wheelScroll.bind(this),this.target.addEventListener("mousedown",this.mouseInteractionStart,!1),this.target.addEventListener("mousemove",this.mouseInteractionMove,!1),this.target.addEventListener("mouseup",this.mouseInteractionEnd,!1),this.target.addEventListener("wheel",this.wheelScroll,!1),this.target.addEventListener("contextmenu",n=>{n.preventDefault()},!1)}mouseInteractionStart(t){this.isDown=!0;const e=this.target.getBoundingClientRect();this.prevPosition=j.create(t.clientX-e.left,t.clientY-e.top)}mouseInteractionMove(t){if(this.isDown!==!0)return;const e=this.target.getBoundingClientRect(),n=e.width,i=e.height,s=t.clientX-e.left,r=t.clientY-e.top,o=1/Math.min(n,i);switch(this.offsetPosition=j.create(s-this.prevPosition[0],r-this.prevPosition[1]),this.prevPosition=j.create(s,r),t.buttons){case 1:this.rotateX+=this.offsetPosition[0]*o,this.rotateY+=this.offsetPosition[1]*o,this.rotateX=this.rotateX%1,this.rotateY=Math.min(Math.max(this.rotateY%1,-.25),.25);break;case 2:const a=U.create(this.offsetPosition[0],-this.offsetPosition[1],0),u=B.toVecIII(a,this.qt);this.movePosition[0]-=u[0]*o*this.moveScale,this.movePosition[1]-=u[1]*o*this.moveScale,this.movePosition[2]-=u[2]*o*this.moveScale;break}}mouseInteractionEnd(t){this.isDown=!1}wheelScroll(t){const e=t.wheelDelta;e>0?this.scale=-.5:e<0&&(this.scale=.5)}update(){const t=Math.PI*2,e=U.create(1,0,0),n=U.create(0,1,0);return this.scale*=.7,this.distance+=this.scale,this.distance=Math.min(Math.max(this.distance,this.minDistance),this.maxDistance),this.defaultPosition[2]=this.distance,B.identity(this.qt),B.identity(this.qtx),B.identity(this.qty),B.rotate(this.rotateX*t,n,this.qtx),B.toVecIII(e,this.qtx,e),B.rotate(this.rotateY*t,e,this.qty),B.multiply(this.qtx,this.qty,this.qt),B.toVecIII(this.defaultPosition,this.qt,this.position),B.toVecIII(this.defaultUpDirection,this.qt,this.upDirection),this.position[0]+=this.movePosition[0],this.position[1]+=this.movePosition[1],this.position[2]+=this.movePosition[2],this.center[0]=this.defaultCenter[0]+this.movePosition[0],this.center[1]=this.defaultCenter[1]+this.movePosition[1],this.center[2]=this.defaultCenter[2]+this.movePosition[2],q.lookAt(this.position,this.center,this.upDirection)}}const tt=`attribute vec3 position;\r
attribute vec3 normal;\r
attribute vec4 color;\r
attribute vec2 uv;\r
\r
uniform mat4 mvpMatrix;\r
uniform mat4 normalMatrix; // 法線変換行列 @@@\r
uniform float uTime;\r
\r
varying vec4 vColor;\r
varying vec3 vNewNormal;\r
varying vec2 vUv;\r
varying vec3 vPosition;\r
\r
const float PI = 3.141592653589793;\r
const float loopAngle = 1.0 / 12.0;\r
\r
// ランダムな数\r
float rand(float n)  { return fract(sin(n) * 43758.5453123); }\r
\r
// map\r
float map(float value, float min1, float max1, float min2, float max2) {\r
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r
}\r
\r
void main() {\r
  vec3 newPosition = position;\r
\r
  // 法線をまず行列で変換する @@@\r
  vec3 newNormal = (normalMatrix * vec4(normal, 0.0)).xyz;\r
\r
  // ふくらみを作る(30°ごと）\r
  float modulo = mod(uv.x, loopAngle) / loopAngle;\r
  float inflate = sin(modulo * PI);\r
  float distanceY = cos(position.y * 0.46 * PI);\r
  inflate = inflate * distanceY + 0.1;\r
\r
  // 下をすぼめる\r
  float pullY = pow(1.0 - smoothstep(0.0, 1.0, distance(position.y, -1.0)), 10.0) * 0.2;\r
\r
  //張り具合:uTime0.8以上でパンパン, 0.6以下同じ\r
  float strength = smoothstep(0.6, 0.8, uTime) * 2.0 - 1.0; //0~0.4->0.8~1 : -1~1\r
  inflate *= strength * 0.12;\r
  \r
  // 大きさXZ\r
  float scaleXZ = smoothstep(0.0, 0.9, uTime) * 0.8 + 0.2; //0.2~1.0\r
\r
  // しぼむ時の横シフト:uTime=0.4以下で\r
  float shiftTime = (1.0 - smoothstep(0.0, 0.4, uTime)) * 1.8; //uTime=0=1,uTime=0.4=0\r
  float shiftXZ = min(shiftTime, distance(position.y, -1.0));\r
\r
  // シワ:uTime=0.6以上無効\r
  float random = rand(position.x * position.y) * (1.0 - smoothstep(0.2, 0.6, uTime)) * 0.04 * -1.0;\r
\r
  // vertex position update\r
  newPosition += normal * inflate;\r
  newPosition.x = (newPosition.x * scaleXZ - newPosition.x * random) + (shiftXZ * 0.5);\r
  newPosition.z = (newPosition.z * scaleXZ - newPosition.z * random) + (shiftXZ * 0.5);\r
  newPosition.y = position.y - pullY - (shiftXZ + (position.x * shiftXZ * 0.1) + (position.z * shiftXZ * 0.2) + random * 0.5);\r
\r
  // varying\r
  vNewNormal = newNormal;\r
  vUv = uv;\r
  vPosition = position;\r
  vColor = color;\r
\r
  // MVP 行列と頂点座標を乗算してから出力する\r
  gl_Position = mvpMatrix * vec4(newPosition, 1.0);\r
  \r
}\r
\r
`,et=`precision mediump float;\r
\r
// varying vec4 vColor;\r
varying vec3 vNewNormal;\r
varying vec2 vUv;\r
varying vec3 vPosition;\r
\r
const float loopAngle = 1.0 / 12.0;\r
\r
// カラー変換\r
vec3 hsv2rgb(vec3 c) {\r
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r
}\r
\r
void main() {\r
  // ライトベクトルはひとまず定数で定義する\r
  const vec3 light = vec3(0.5, 0.5, 1.0);\r
\r
  // 変換した法線とライトベクトルで内積を取る @@@\r
  float d = dot(normalize(vNewNormal), normalize(light));\r
  d = d * 0.25 + 0.75; //0.5-1.0\r
\r
  // color\r
  float hueAngle = floor(vUv.x / loopAngle);\r
  float hue = loopAngle * hueAngle;\r
  vec3 hsv = vec3(hue, 0.8, 0.8);\r
  vec3 newColor = vec3(hsv2rgb(hsv));\r
  // alpha 上下を切り落とす\r
  float alpha = 1.0 - step(0.99, vPosition.y);\r
  alpha *= step(0.06, vPosition.y + 1.0);\r
\r
  gl_FragColor = vec4(newColor * d, alpha);\r
}\r
\r
`;window.addEventListener("DOMContentLoaded",()=>{const z=new nt;z.init(),z.createProgramObject(tt,et),z.setupGeometry(),z.setupLocation(),z.setBlending(!0),z.setCulling(!1),z.start();const t=new Q,e={texture:!0,blend:!0};t.add(e,"blend").onChange(n=>{z.setBlending(n)})});class nt{constructor(){this.canvas=null,this.gl=null,this.program=null,this.attributeLocation=null,this.attributeStride=null,this.uniformLocation=null,this.camera=null,this.geometry=null,this.baloonVBO=null,this.balloonIBO=null,this.startTime=0,this.isRender=!1,this.isRotation=!1,this.resize=this.resize.bind(this),this.render=this.render.bind(this)}setBlending(t){const e=this.gl;e!=null&&(t===!0?e.enable(e.BLEND):e.disable(e.BLEND))}setCulling(t){const e=this.gl;e!==null&&(t?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE))}setDepthTest(t){const e=this.gl;e!==null&&(t?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST))}setRotation(t){this.isRotation=t}init(){this.canvas=document.getElementById("webgl-canvas"),this.gl=N.createWebGLContext(this.canvas);const t={distance:5,min:1,max:10,move:2};this.camera=new Y(this.canvas,t),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST),this.resize(),window.addEventListener("resize",this.resize,!1)}createProgramObject(t,e){const n=this.gl;if(n!=null){const i=N.createShaderObject(n,t,n.VERTEX_SHADER),s=N.createShaderObject(n,e,n.FRAGMENT_SHADER);this.program=N.createProgramObject(n,i,s)}}setupGeometry(){const t=[1,1,1,1],e=24,n=128,i=1;this.geometry=J.sphere(e,n,i,t),this.baloonVBO=[N.createVBO(this.gl,this.geometry.position),N.createVBO(this.gl,this.geometry.normal),N.createVBO(this.gl,this.geometry.color),N.createVBO(this.gl,this.geometry.texCoord)],this.balloonIBO=N.createIBO(this.gl,this.geometry.index)}setupLocation(){const t=this.gl;this.attributeLocation=[t.getAttribLocation(this.program,"position"),t.getAttribLocation(this.program,"normal"),t.getAttribLocation(this.program,"color"),t.getAttribLocation(this.program,"uv")],this.attributeStride=[3,3,4,2],this.uniformLocation={mvpMatrix:t.getUniformLocation(this.program,"mvpMatrix"),normalMatrix:t.getUniformLocation(this.program,"normalMatrix"),uTime:t.getUniformLocation(this.program,"uTime")}}setupRendering(){const t=this.gl;t.viewport(0,0,this.canvas.width,this.canvas.height),t.clearColor(.3,.3,.3,1),t.clearDepth(1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE)}start(){this.startTime=Date.now(),this.isRender=!0,this.render()}stop(){this.isRender=!1}resize(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}render(){const t=this.gl,e=H.Mat4;this.isRender===!0&&requestAnimationFrame(this.render);const n=(Date.now()-this.startTime)*.001,i=Math.abs(Math.sin(n*.3));this.setupRendering();const s=e.translate(e.identity(),[0,i,0]),r=e.transpose(e.inverse(s)),o=this.camera.update(),a=45,u=window.innerWidth/window.innerHeight,c=.1,l=10,h=e.perspective(a,u,c,l),f=e.multiply(h,o),g=e.multiply(f,s);t.useProgram(this.program),t.uniformMatrix4fv(this.uniformLocation.mvpMatrix,!1,g),t.uniformMatrix4fv(this.uniformLocation.normalMatrix,!1,r),t.uniform1f(this.uniformLocation.uTime,i),N.enableBuffer(t,this.baloonVBO,this.attributeLocation,this.attributeStride,this.balloonIBO),t.drawElements(t.TRIANGLES,this.geometry.index.length,t.UNSIGNED_SHORT,0)}}
